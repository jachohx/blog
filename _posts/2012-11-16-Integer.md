---
layout: get
title: Integer的自动装箱与拆箱
description: Integer的自动装箱与拆箱
category: tech
tags: int,Integer
---
最近看到一行代码

	map.put(key, Integer.valueOf("1"));

Map是HashMap<String, Integer>();

首先这行代码效率肯定是很低的，1是数字，然后转成了字符，再转成数字。

首先，既然是数字，那么就没有必要用“1”了，直接Integer.valueOf(1)就可以了。

最简单的写法是1。

但考虑到自动装箱boxing 是在JDK1.5后才有的，所以1.4还是要用new Integer(1)或Integer(1)。

下面来看下这段代码

	Integer i1 = 1;
	Integer i2 = new Integer(1);
	Integer i3 = Integer.valueOf(1);	
	Integer i4 = Integer.valueOf("1");
	Integer i5 = 129;		
	int i6 = i5;

在Class文件里可以看到

	0  iconst_1
	1  invokestatic java.lang.Integer.valueOf(int) : java.lang.Integer [16]
	4  astore_1 [i1]
	5  new java.lang.Integer [17]
	8  dup
	9  iconst_1
	10  invokespecial java.lang.Integer(int) [22]
	13  astore_2 [i2]
	14  iconst_1
	15  invokestatic java.lang.Integer.valueOf(int) : java.lang.Integer [16]
	18  astore_3 [i3]
	19  ldc <String "1"> [25]
	21  invokestatic java.lang.Integer.valueOf(java.lang.String) : java.lang.Integer [27]
	24  astore 4 [i4]
	26  sipush 129
	29  invokestatic java.lang.Integer.valueOf(int) : java.lang.Integer [16]
	32  astore 5 [i5]
	34  aload 5 [i5]
	36  invokevirtual java.lang.Integer.intValue() : int [30]
	39  istore 6 [i6]
    
i1是1，JDK会自动装箱boxing，调用Integer.valueOf(int)方法。与i3是一样的效果。

而i2是直接new 一个新的Integer。

i4也调用了valueOf方法，不过比valueOf(int)多了一个步骤parseInt(s, 10)。

i5与i1一样，不过还是有一点区别，等下再看下valueOf的方法。

i6是一个自动拆箱unboxing，调用Integer.intValue方法。

下面再来看下valueOf(int)这个方法

	public static Integer valueOf(int i) {
		final int offset = 128;
		if (i >= -128 && i <= 127) { // must cache 
			return IntegerCache.cache[i + offset];
		}
		return new Integer(i);
	}

在看下IntegerCache

	private static class IntegerCache {
		private IntegerCache(){}

		static final Integer cache[] = new Integer[-(-128) + 127 + 1];

		static {
			for(int i = 0; i < cache.length; i++)
			cache[i] = new Integer(i - 128);
		}
	}

IntegerCache会对-128~127之间的数做一个缓存，在valueOf方法里，对-128~127之间的数直接使用IntegerCache缓存，不在这个范围的，则new Integer(int)方法。

	System.out.println(Integer.valueOf(127) == Integer.valueOf(127));
	System.out.println(Integer.valueOf(129) == Integer.valueOf(129));

这两个的输出是true，false，也就是第一个用了缓存，第二个都是new出来的对象。

所以最开始那个代码可以使用

	map.put(key, 1);

当然为了兼容1.4那么就写成

	map.put(key, Integer.valueOf(1));
	
但最好不要用

	map.put(key, new Integer(1));