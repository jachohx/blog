{"pages":[],"posts":[{"title":"使用Github Pages建独立博客","text":"Github很好的将代码和社区联系在了一起，于是发生了很多有趣的事情，世界也因为他美好了一点点。Github作为现在最流行的代码仓库，已经得到很多大公司和项目的青睐，比如jQuery、Twitter等。为使项目更方便的被人理解，介绍页面少不了，甚至会需要完整的文档站，Github替你想到了这一点，他提供了Github Pages的服务，不仅可以方便的为项目建立介绍站点，也可以用来建立个人博客。 Github Pages有以下几个优点： 轻量级的博客系统，没有麻烦的配置 使用标记语言，比如Markdown 无需自己搭建服务器 根据Github的限制，对应的每个站有300MB空间 可以绑定自己的域名 当然他也有缺点： 使用Jekyll模板系统，相当于静态页发布，适合博客，文档介绍等。 动态程序的部分相当局限，比如没有评论，不过还好我们有解决方案。 基于Git，很多东西需要动手，不像Wordpress有强大的后台 大致介绍到此，作为个人博客来说，简洁清爽的表达自己的工作、心得，就已达目标，所以Github Pages是我认为此需求最完美的解决方案了。 购买、绑定独立域名虽说Godaddy曾支持过SOPA，并且首页放着极其不专业的大胸美女，但是作为域名服务商他做的还不赖，选择它最重要的原因是他支持支付宝，没有信用卡有时真的很难过。 域名的购买不用多讲，注册、选域名、支付，有网购经验的都毫无压力，优惠码也遍地皆是。域名的配置需要提醒一下，因为伟大英明的GFW的存在，我们必须多做些事情。 流传Godaddy的域名解析服务器被墙掉，导致域名无法访问，后来这个事情在BeiYuu也发生了，不得已需要把域名解析服务迁移到国内比较稳定的服务商处，这个迁移对于域名来说没有什么风险，最终的控制权还是在Godaddy那里，你随时都可以改回去。 我们选择DNSPod的服务，他们的产品做得不错，易用、免费，收费版有更高端的功能，暂不需要。注册登录之后，按照DNSPod的说法，只需三步（我们插入一步）： 首先添加域名记录，可参考DNSPod的帮助文档：https://www.dnspod.cn/Support 在DNSPod自己的域名下添加一条A记录，地址就是Github Pages的服务IP地址：207.97.227.245 在域名注册商处修改DNS服务:去Godaddy修改Nameservers为这两个地址：f1g1ns1.dnspod.net、f1g1ns2.dnspod.net。如果你不明白在哪里修改，可以参考这里：Godaddy注册的域名如何使用DNSPod 等待域名解析生效 域名的配置部分完成，跪谢方校长。 配置和使用GithubGit是版本管理的未来，他的优点我不再赘述，相关资料很多。推荐这本Git中文教程。 要使用Git，需要安装它的客户端，推荐在Linux下使用Git，会比较方便。Windows版的下载地址在这里：http://code.google.com/p/msysgit/downloads/list。其他系统的安装也可以参考官方的安装教程。 下载安装客户端之后，各个系统的配置就类似了，我们使用windows作为例子，Linux和Mac与此类似。 在Windows下，打开Git Bash，其他系统下面则打开终端（Terminal）： 1、检查SSH keys的设置首先我们需要检查你电脑上现有的ssh key： 1$ cd /.ssh 如果显示“No such file or directory”，跳到第三步，否则继续。 2、备份和移除原来的ssh key设置：因为已经存在key文件，所以需要备份旧的数据并删除： 12345$ lsconfig id_rsa id_rsa.pub known_hosts$ mkdir key_backup$ cp id_rsa* key_backup$ rm id_rsa* 3、生成新的SSH Key：输入下面的代码，就可以生成新的key文件，我们只需要默认设置就好，所以当需要输入文件名的时候，回车就好。 123$ ssh-keygen -t rsa -C \"邮件地址@youremail.com\"Generating public/private rsa key pair.Enter file in which to save the key (/Users/your_user_directory/.ssh/id_rsa):&lt;回车就好&gt; 然后系统会要你输入加密串（Passphrase）： Enter passphrase (empty for no passphrase):&lt;输入加密串&gt; Enter same passphrase again:&lt;再次输入加密串&gt;最后看到这样的界面，就成功设置ssh key了： 4、添加SSH Key到GitHub：在本机设置SSH Key之后，需要添加到GitHub上，以完成SSH链接的设置。 用文本编辑工具打开id_rsa.pub文件，如果看不到这个文件，你需要设置显示隐藏文件。准确的复制这个文件的内容，才能保证设置的成功。 在GitHub的主页上点击设置按钮： 选择SSH Keys项，把复制的内容粘贴进去，然后点击Add Key按钮即可： PS：如果需要配置多个GitHub账号，可以参看这个多个github帐号的SSH key切换，不过需要提醒一下的是，如果你只是通过这篇文章中所述配置了Host，那么你多个账号下面的提交用户会是一个人，所以需要通过命令git config --global --unset user.email删除用户账户设置，在每一个repo下面使用git config --local user.email '你的github邮箱@mail.com' 命令单独设置用户账户信息 5、测试一下可以输入下面的命令，看看设置是否成功，git@github.com的部分不要修改： 1$ ssh -T git@github.com 如果是下面的反应： The authenticity of host &apos;github.com (207.97.227.239)&apos; can&apos;t be established. RSA key fingerprint is 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48. Are you sure you want to continue connecting (yes/no)?不要紧张，输入yes就好，然后会看到： Hi &lt;em&gt;username&lt;/em&gt;! You&apos;ve successfully authenticated, but GitHub does not provide shell access.6、设置你的账号信息现在你已经可以通过SSH链接到GitHub了，还有一些个人信息需要完善的。 Git会根据用户的名字和邮箱来记录提交。GitHub也是用这些信息来做权限的处理，输入下面的代码进行个人信息的设置，把名称和邮箱替换成你自己的，名字必须是你的真名，而不是GitHub的昵称。 12$ git config --global user.name \"你的名字\"$ git config --global user.email \"your_email@youremail.com\" 设置GitHub的token2012-4-28补充：新版的接口已经不需要配置token了，所以下面这段可以跳过了 有些工具没有通过SSH来链接GitHub。如果要使用这类工具，你需要找到然后设置你的API Token。 在GitHub上，你可以点击Account Setting &gt; Account Admin： 然后在你的命令行中，输入下面的命令，把token添加进去： 12$ git config --global user.name \"你的名字\"$ git config --global user.token 0123456789your123456789token 如果你改了GitHub的密码，需要重新设置token。 成功了好了，你已经可以成功连接GitHub了。 使用GitHub Pages建立博客与GitHub建立好链接之后，就可以方便的使用它提供的Pages服务，GitHub Pages分两种，一种是你的GitHub用户名建立的username.github.com这样的用户&amp;组织页（站），另一种是依附项目的pages。 User &amp; Organization Pages想建立个人博客是用的第一种，形如beiyuu.github.com这样的可访问的站，每个用户名下面只能建立一个，创建之后点击Admin进入项目管理，可以看到是这样的：而普通的项目是这样的，即使你也是用的othername.github.com： 创建好username.github.com项目之后，提交一个index.html文件，然后push到GitHub的master分支（也就是普通意义上的主干）。第一次页面生效需要一些时间，大概10分钟左右。 生效之后，访问username.github.com就可以看到你上传的页面了，beiyuu.github.com就是一个例子。 关于第二种项目pages，简单提一下，他和用户pages使用的后台程序是同一套，只不过它的目的是项目的帮助文档等跟项目绑定的内容，所以需要在项目的gh-pages分支上去提交相应的文件，GitHub会自动帮你生成项目pages。具体的使用帮助可以参考Github Pages的官方文档： 绑定域名我们在第一部分就提到了在DNS部分的设置，再来看在GitHub的配置，要想让username.github.com能通过你自己的域名来访问，需要在项目的根目录下新建一个名为CNAME的文件，文件内容形如： beiyuu.com 你也可以绑定在二级域名上： blog.beiyuu.com 需要提醒的一点是，如果你使用形如beiyuu.com这样的一级域名的话，需要在DNS处设置A记录到207.97.227.245（此处每个人的地址都不同，需要根据Github提供的地址自行修改），而不是在DNS处设置为CNAME的形式，否则可能会对其他服务（比如email）造成影响。 设置成功后，根据DNS的情况，最长可能需要一天才能生效，耐心等待吧。 Jekyll模板系统GitHub Pages为了提供对HTML内容的支持，选择了Jekyll作为模板系统，Jekyll是一个强大的静态模板系统，作为个人博客使用，基本上可以满足要求，也能保持管理的方便，你可以查看Jekyll官方文档。 你可以直接fork我的项目，然后改名，就有了你自己的满足Jekyll要求的文档了，当然你也可以按照下面的介绍自己创建。 Jekyll基本结构Jekyll的核心其实就是一个文本的转换引擎，用你最喜欢的标记语言写文档，可以是Markdown、Textile或者HTML等等，再通过layout将文档拼装起来，根据你设置的URL规则来展现，这些都是通过严格的配置文件来定义，最终的产出就是web页面。 基本的Jekyll结构如下： |-- _config.yml |-- _includes |-- _layouts | |-- default.html | `-- post.html |-- _posts | |-- 2007-10-29-why-every-programmer-should-play-nethack.textile | `-- 2009-04-26-barcamp-boston-4-roundup.textile |-- _site `-- index.html简单介绍一下他们的作用： _config.yml配置文件，用来定义你想要的效果，设置之后就不用关心了。 _includes可以用来存放一些小的可复用的模块，方便通过{ % include file.ext %}（去掉前两个{中或者{与%中的空格，下同）灵活的调用。这条命令会调用_includes/file.ext文件。 _layouts这是模板文件存放的位置。模板需要通过YAML front matter来定义，后面会讲到，{ { content }}标记用来将数据插入到这些模板中来。 _posts你的动态内容，一般来说就是你的博客正文存放的文件夹。他的命名有严格的规定，必须是2012-02-22-artical-title.MARKUP这样的形式，MARKUP是你所使用标记语言的文件后缀名，根据_config.yml中设定的链接规则，可以根据你的文件名灵活调整，文章的日期和标记语言后缀与文章的标题的独立的。 _site这个是Jekyll生成的最终的文档，不用去关心。最好把他放在你的.gitignore文件中忽略它。 其他文件夹你可以创建任何的文件夹，在根目录下面也可以创建任何文件，假设你创建了project文件夹，下面有一个github-pages.md的文件，那么你就可以通过yoursite.com/project/github-pages访问的到，如果你是使用一级域名的话。文件后缀可以是.html或者markdown或者textile。这里还有很多的例子：https://github.com/mojombo/jekyll/wiki/Sites Jekyll的配置Jekyll的配置写在_config.yml文件中，可配置项有很多，我们不去一一追究了，很多配置虽有用但是一般不需要去关心，官方配置文档有很详细的说明，确实需要了可以去这里查，我们主要说两个比较重要的东西，一个是Permalink，还有就是自定义项。 Permalink项用来定义你最终的文章链接是什么形式，他有下面几个变量： year 文件名中的年份 month 文件名中的月份 day 文件名中的日期 title 文件名中的文章标题 categories 文章的分类，如果文章没有分类，会忽略 i-month 文件名中的除去前缀0的月份 i-day 文件名中的除去前缀0的日期 看看最终的配置效果： permalink: pretty /2009/04/29/slap-chop/index.html permalink: /:month-:day-:year/:title.html /04-29-2009/slap-chop.html permalink: /blog/:year/:month/:day/:title /blog/2009/04/29/slap-chop/index.html 我使用的是： permalink: /:title /github-pages 自定义项的内容，例如我们定义了title:BeiYuu的博客这样一项，那么你就可以在文章中使用{ { site.title }}来引用这个变量了，非常方便定义些全局变量。 YAML Front Matter和模板变量对于使用YAML定义格式的文章，Jekyll会特别对待，他的格式要求比较严格，必须是这样的形式： --- layout: post title: Blogging Like a Hacker ---前后的---不能省略，在这之间，你可以定一些你需要的变量，layout就是调用_layouts下面的某一个模板，他还有一些其他的变量可以使用： permalink 你可以对某一篇文章使用通用设置之外的永久链接 published 可以单独设置某一篇文章是否需要发布 category 设置文章的分类 tags 设置文章的tag 上面的title就是自定义的内容，你也可以设置其他的内容，在文章中可以通过{ { page.title }}这样的形式调用。 模板变量，我们之前也涉及了不少了，还有其他需要的变量，可以参考官方的文档：https://github.com/mojombo/jekyll/wiki/template-data 使用Disqus管理评论模板部分到此就算是配置完毕了，但是Jekyll只是个静态页面的发布系统，想做到关爽场倒是很容易，如果想要评论呢？也很简单。 现在专做评论模块的产品有很多，比如Disqus，还有国产的多说，Disqus对现在各种系统的支持都比较全面，到写博客为止，多说现在仅是WordPress的一个插件，所以我这里暂时也使用不了，多说与国内的社交网络紧密结合，还是有很多亮点的，值得期待一下。我先选择了Disqus。 注册账号什么的就不提了，Disqus支持很多的博客平台，参见下图： 我们选择最下面的Universal Code就好，然后会看到一个介绍页面，把下面这段代码复制到你的模板里面，可以只复制到显示文章的模板中： 1234567891011121314&lt;div id=\"disqus_thread\"&gt;&lt;/div&gt;&lt;script type=\"text/javascript\"&gt; /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */ var disqus_shortname = 'example'; // required: replace example with your forum shortname 这个地方需要改成你配置的网站名 /* * * DON'T EDIT BELOW THIS LINE * * */ (function() { var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true; dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js'; (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq); })();&lt;/script&gt;&lt;noscript&gt;Please enable JavaScript to view the &lt;a href=\"http://disqus.com/?ref_noscript\"&gt;comments powered by Disqus.&lt;/a&gt;&lt;/noscript&gt;&lt;a href=\"http://disqus.com\" class=\"dsq-brlink\"&gt;blog comments powered by &lt;span class=\"logo-disqus\"&gt;Disqus&lt;/span&gt;&lt;/a&gt; 配置完之后，你也可以做一些异步加载的处理，提高性能，比如我就在最开始页面打开的时候不显示评论，当你想看评论的时候，点击“显示评论”再加载Disqus的模块。代码很简单，你可以参考我的写法。 123456$('#disqus_container .comment').on('click',function(){ $(this).html('加载中...'); var disqus_shortname = 'beiyuu'; var that = this; BYB.includeScript('http://' + disqus_shortname + '.disqus.com/embed.js',function(){$(that).remove()}); //这是一个加载js的函数}); 如果你不喜欢Disqus的样式，你也可以根据他生成的HTML结构，自己改写样式覆盖它的，Disqus现在也提供每个页面的评论数接口，帮助文档在这里可以看到。 代码高亮插件如果写技术博客，代码高亮少不了，有两个可选插件DlHightLight代码高亮组件和Google Code Prettify。DLHightLight支持的语言相对较少一些，有js、css、xml和html，Google的高亮插件基本上任何语言都支持，也可以自定义语言，也支持自动识别，也有行号的特别支持。 Google的高亮插件使用也比较方便，只需要在&lt;pre&gt;的标签上加入prettyprint即可。所以我选择了Google Code Prettify。 搭建本地jekyll环境这里主要介绍一下在Mac OS X下面的安装过程，其他操作系统可以参考官方的jekyll安装。 作为生活在水深火热的墙内人民，有必要进行下面一步修改gem的源，方便我们更快的下载所需组建： 12sudo gem sources --remove http://rubygems.org/ sudo gem sources -a http://ruby.taobao.org/ 然后用Gem安装jekyll 1$ gem install jekyll 不过一般如果有出错提示，你可能需要这样安装： 1$ sudo gem install jekyll 如果这个时候出现gem找不到，则要安装ruby 1sudo apt-get install ruby1.9.1-dev 我到了这一步的时候总是提示错误Failed to build gem native extension，很可能的一个原因是没有安装rvm，rvm的安装可以参考这里，或者敲入下面的命令： 1$ curl -L https://get.rvm.io | bash -s stable --ruby 然后还需要安装Markdown的解释器，这个需要在你的_config.yml里面设置markdown:rdiscount： 1$ gem install jekyll rdiscount 好了，如果一切顺利的话，本地环境就基本搭建完成了，进入之前我们建立的博客目录，运行下面的命令： 1$ jekyll --server 这个时候，你就可以通过localhost:4000来访问了。还有关于jekyll bootstrap的资料，需要自己修改调试的，可以研究一下。 我在这个过程中还遇到两个诡异的没有解决的问题，一个是我放在根目录下面的blog.md等文件，在GitHub的pages服务上一切正常，可以通过beiyuu.com/blog访问的到，但是在本地环境下，总是not found，很是让人郁闷，看生成的_site目录下面的文件，也是正常的blog.html，但就是找不到，只有当我把URL改为localhost:4000/blog.html的时候，才能访问的到，环境不同真糟糕。 还有一个是关于category的问题，根据YAML的语法，我们在文章头部可以定义文章所属的类别，也可以定义为category:[blog,rss]这样子的多类别，我在本地试一切正常，但是push到GitHub之后，就无法读取了，真让人着急，没有办法，只能采用别的办法满足我的需求了。这里还有一篇Jekyll 本地调试之若干问题，安装中如果有其他问题，也可以对照参考一下。 Windows搭建jekyll环境由于平时使用windows环境多，所以还要在本地搭建windows版本的jekyll。 由于jekyll是用ruby语言写的一个静态网页生成工具，所以要搭建jekyll本地环境就需要先配置好ruby环境。 配置ruby环境 由于jekyll是用ruby语言写的一个静态网页生成工具，所以要搭建jekyll本地环境就需要先配置好ruby环境。 1）去官网下载Ruby：https://www.ruby-lang.org/zh_cn/downloads/，可以是安装包类型，也可以是解压版的。 2）如果是安装版，则默认会给你配置系统环境变量，如果是解压版的，则需要自己配置系统环境变量。虽然本人喜欢解压版的，但由于本人功力还不够，发现解压版的缺少很多必要的东东，无奈只能罢了。（当然如果一定要解压版的，就把别人安装好的拷过来吧！） 3）鉴于本人是初学者吧，而且官方推荐不知道如何安装的，就选择RubyInstaller（这种安装方式除 Ruby 之外，捆绑一些额外的资源库。）。所以上面两步就略过了，呵呵，下载了“rubyinstaller-1.9.3-p429.exe”，记得安装的时候选上“Add Ruby executables to your PATH”（添加系统环境变量），我这里安装到了C:\\Ruby下 4）下载DevKit，解压进行执行相关命令（至于为啥，我还不懂，这个是win系统下必要的步骤）。我解压到了C:\\devkit下，打开cmd，切换到C:\\devkit下，分步执行如下红色字样命令，出现如下提示表示安装成功了： C:\\&gt;cd devkit C:\\devkit&gt;ruby dk.rb init [INFO] found RubyInstaller v1.9.3 at C:/Ruby Initialization complete! Please review and modify the auto-generated 'config.yml' file to ensure it contains the root directories to all of the installed Rubies you want enhanced by the DevKit. C:\\devkit&gt;ruby dk.rb install [INFO] Updating convenience notice gem override for 'C:/Ruby' [INFO] Installing 'C:/Ruby/lib/ruby/site_ruby/devkit.rb' 安装jekyll 打开cmd，执行如下红色字样命令（gem命令已在系统环境中，后面的jekyll亦如此），出现如下类似信息表示安装成功（这里会安装jekyll所依赖的东西，由于是联网安装，所以存在连接速度等网络问题，如果出现错误，在确认前面安装步骤正常的情况下请多尝试，耐心等待！！！事后添加[2013-10-08]：修改gem命令代码源为ruby.taobao.org速度应该会较快的，具体设置见：http://ruby.taobao.org）： C:\\&gt;gem install jekyll rdiscount 这一步跟Mac OS X差不多。 查看版本： jekyll -v 使用jekyll创建网站并运行 切换到jekyll目录，执行 jekyll serve然后通过http://localhost:4000来访问即可。 结语如果你跟着这篇不那么详尽的教程，成功搭建了自己的博客，恭喜你！剩下的就是保持热情的去写自己的文章吧。 原文转自 使用Github Pages建独立博客","link":"/2012/10/11/github-pages/"},{"title":"Integer的自动装箱与拆箱","text":"最近看到一行代码 1map.put(key, Integer.valueOf(\"1\")); Map是HashMap&lt;String, Integer&gt;(); 首先这行代码效率肯定是很低的，1是数字，然后转成了字符，再转成数字。 首先，既然是数字，那么就没有必要用“1”了，直接Integer.valueOf(1)就可以了。 最简单的写法是1。 但考虑到自动装箱boxing 是在JDK1.5后才有的，所以1.4还是要用new Integer(1)或Integer(1)。 下面来看下这段代码 123456Integer i1 = 1;Integer i2 = new Integer(1);Integer i3 = Integer.valueOf(1); Integer i4 = Integer.valueOf(\"1\");Integer i5 = 129; int i6 = i5; 在Class文件里可以看到 12345678910111213141516171819200 iconst_11 invokestatic java.lang.Integer.valueOf(int) : java.lang.Integer [16]4 astore_1 [i1]5 new java.lang.Integer [17]8 dup9 iconst_110 invokespecial java.lang.Integer(int) [22]13 astore_2 [i2]14 iconst_115 invokestatic java.lang.Integer.valueOf(int) : java.lang.Integer [16]18 astore_3 [i3]19 ldc &lt;String \"1\"&gt; [25]21 invokestatic java.lang.Integer.valueOf(java.lang.String) : java.lang.Integer [27]24 astore 4 [i4]26 sipush 12929 invokestatic java.lang.Integer.valueOf(int) : java.lang.Integer [16]32 astore 5 [i5]34 aload 5 [i5]36 invokevirtual java.lang.Integer.intValue() : int [30]39 istore 6 [i6] i1是1，JDK会自动装箱boxing，调用Integer.valueOf(int)方法。与i3是一样的效果。 而i2是直接new 一个新的Integer。 i4也调用了valueOf方法，不过比valueOf(int)多了一个步骤parseInt(s, 10)。 i5与i1一样，不过还是有一点区别，等下再看下valueOf的方法。 i6是一个自动拆箱unboxing，调用Integer.intValue方法。 下面再来看下valueOf(int)这个方法 1234567public static Integer valueOf(int i) { final int offset = 128; if (i &gt;= -128 &amp;&amp; i &lt;= 127) { // must cache return IntegerCache.cache[i + offset]; } return new Integer(i);} 在看下IntegerCache 12345678910private static class IntegerCache { private IntegerCache(){} static final Integer cache[] = new Integer[-(-128) + 127 + 1]; static { for(int i = 0; i &lt; cache.length; i++) cache[i] = new Integer(i - 128); }} IntegerCache会对-128~127之间的数做一个缓存，在valueOf方法里，对-128~127之间的数直接使用IntegerCache缓存，不在这个范围的，则new Integer(int)方法。 12System.out.println(Integer.valueOf(127) == Integer.valueOf(127));System.out.println(Integer.valueOf(129) == Integer.valueOf(129)); 这两个的输出是true，false，也就是第一个用了缓存，第二个都是new出来的对象。 所以最开始那个代码可以使用 1map.put(key, 1); 当然为了兼容1.4那么就写成 1map.put(key, Integer.valueOf(1)); 但最好不要用 1map.put(key, new Integer(1));","link":"/2012/11/16/Integer/"},{"title":"Eclipse下将项目增加maven配置","text":"最近的项目开始使用maven做托管，于是开始熟悉maven环境，安装，配置那些就不用多说了，直接用eclipse默认的就OK了。 关键在于，有时新建的项目不能导入maven的依赖包，虽然maven可以compile，但源代码会有报错。 出现红叉看起来很是不错。 于是开始研究一些可以自动导入maven包的项目。 .project 增加maven项目项目的配置文件.project 在下的配置如下： &lt;buildSpec&gt; &lt;buildCommand&gt; &lt;name&gt;org.eclipse.jdt.core.javabuilder&lt;/name&gt; &lt;arguments&gt; &lt;/arguments&gt; &lt;/buildCommand&gt; &lt;buildCommand&gt; &lt;name&gt;org.eclipse.m2e.core.maven2Builder&lt;/name&gt; &lt;arguments&gt; &lt;/arguments&gt; &lt;/buildCommand&gt; &lt;/buildSpec&gt; &lt;natures&gt; &lt;nature&gt;org.eclipse.jdt.core.javanature&lt;/nature&gt; &lt;nature&gt;org.eclipse.m2e.core.maven2Nature&lt;/nature&gt; &lt;/natures&gt;只要buildSpec，natures下加入m2e的那两段代码就可以了。 在.project下增加了那两段代码后，项目及pom.xml可以右键run maven。 但是这样还是没有引入maven依赖。 .classpath 增加maven 的依赖而.classpath下多了这几行代码： &lt;classpathentry kind=&quot;con&quot; path=&quot;org.eclipse.m2e.MAVEN2_CLASSPATH_CONTAINER&quot;&gt; &lt;attributes&gt; &lt;attribute name=&quot;maven.pomderived&quot; value=&quot;true&quot;/&gt; &lt;/attributes&gt; &lt;/classpathentry&gt;只要把以上的代码加入到下就可以了。maven的包依赖就会导入了。 好了，只要在这两个配置文件里增加了了maven配置，整个maven就可以用了。","link":"/2013/03/07/eclipse-maven/"},{"title":"用vps写jekyll","text":"用github写博客，把_post下的文件放到github上，用它的jekyll来生成静态文件，不过有一个问题，它的jekyll版本可能跟我的不一样，别人也有遇到这样的情况。 所以自己生成静态文件，再放到github上会更佳。 在Windows在要搭jekyll，安装起来真的很麻烦，各种折腾。 现在md的语法熟悉了之后，就没有必要蛋痛地在本地搭jekyll。 于是在VPS上搭了一个jekyll环境，然后只需要把源文件同步到vps上就可以了。 在Windows下用rsync这个工具可以还是不错的。 upload.bat脚本： bin\\rsync -av /blog/src/ user@ip::blogblog是在vps上的/etc/rsyncd.conf上加上 [blog] path=/var/www/blog/src read only=false auth users=userdown.bat bin\\rsync -av rsync@216.18.193.125::blog /blog/src/upload.bat与down.bat文件放在rsync的bin同级目录，且当前有/src/blog目录 现在的问题是，如何在vps上把post文件生成静态文件，然后再上传到github。 blog下的目录是这样的 |-- git (git静态文件) |-- log (更新日志) |-- src (jekyll项目) | |-- (jekyll配置) | `-- update.txt |-- check.sh |-- git.sh |-- time |-- update.shcheck.sh 定时检查项目有没有更新，time记录下上一次的更新时间，update.txt是每次要提交的更新说明，如果有修改，说明有更新 cd /var/www/blog time=`stat -c %Z src/update.txt` last=`cat time` if [[ $time -ne $last ]];then ./update.sh echo $time &gt; time fiupdate.sh 检查到有更新，用jekyll生成静态文件 base=/var/www/blog cd $base/src jekyll commit=`cat update.txt` cd $base log=$base/log/git.log $base/git.sh $commit &gt;&gt; $loggit.sh 把静态文件的修改更新到github上 commit=$1 cd /var/www/blog cp -rf src/_site/* git/ cd git echo &apos;------------------------------&apos; echo $commit echo `date &apos;+%Y-%m-%d %T&apos;` git st git add . for delfile in `git st | grep deleted | awk &apos;{print $3}&apos;`;do git rm $delfile done git cm &quot;$commit&quot; git push OK，到这样的话就可以在windows下写md文件，且同步到github上了","link":"/2013/02/06/jekyll-rsync/"},{"title":"秒杀系统","text":"背景奖品是提前插入到数据库，大概有上百万。 每个奖品的字段有 id。奖品ID name。奖品名称 startTime。奖品领取时间 status。奖品状态，0：未领，1：已领。 uid。领取的用户ID。 updateTime。奖品更新时间。 需要返回奖品id、name。 过程抽奖的流程： 判断用户是否合法。 判断用户是否有抽奖机会。 抽奖。 拿奖品。去数据库拿奖品。 更新奖品。根据奖品ID更新数据库为自己领取。 返回奖品信息。 每个用户得到奖品的查询SQL语句： 1select \\* from tablename where startTime \\&gt; unix\\_timestamp() and status = 0 limit 1; 拿到奖品ID更新用户奖品SQL： 1update tablename set uid = xxx, status = 1, updateTime = UNIX\\_TIMESTAMP() where id = xxx; 上边的步骤都是独立线程完成的。 在第1、2步都没有问题，但在第3步的时候，在多线程的时候，会出现问题；拿奖品的时候，在高并发的时候，一个奖品可能被多个用户拿到，再更新奖品的时候就更新不了。 优化第3步，思路是，先查看奖品可以拿，然后再更新为自己的。之所以出现问题是，在多线程并发访问的时候，查询的SQL在同一个时间内被执行很多次，查询出来的结果可能奖品ID是一样，那么更新的时候就会出错，更新不成功。 那我们可以换一个思路，可以是，先领取奖品，有领取到奖品然后再查询领取了什么奖品。 抽奖。 领取奖品。 查看奖品信息。 领取奖品的SQL：(time是传递值) 1update tablename set uid = xxx, status = 1, updateTime = time where startTime \\&gt; time and status = 0 limit 1; 查看奖品信息的SQL： 1select \\* from tablename where uid = xxx and updateTime = time and status = 1; 领取奖品的SQL是上面过程两个SQL的结合，不同的是，时间是不是数据库时间，是程序时间，为了方便 的时候，可能方式有所不一样，比如，根据条件直接更新奖品，然后再去查出更新了哪个奖品。 但无论哪种方式，都是贸易","link":"/2014/06/01/lottery/"},{"title":"网站改造","text":"背景虎牙网站经过几年的发展，已经达到了千万PV级别的网站，业务也越来越多，提供的数据也越来越多，传统的MVC模式已经越来越不适合业务的发展，所以要对网站进行模块分隔。 一个应用发展到了一定级别的时候，就需要将应用分隔多个小的应用，从而使的应用之间的影响变得越来越小。比如，后台、用户中心、主站、第三方接口等应用。这些应用之间相互联系是很少的，而且职责都明显，完全可以独立出来做一个应用。且每个应用的的访问量也是有区别，那么可以根据不同的访问量来给应用分线程。 按应用分隔在很多的网站都已经是这样做了，在一开始的时候很多开发者就考虑这样做了，所以按应用分隔并不是什么重要的解决方案。 弊端传统的MVC，一般是C层从M层拿到数据，然后再传给V层显示出来，一般在M或C层会做一下缓存。 相信很多的网站开始的时候都按这种MVC来建站的，当然MVC是有很多的优点，相信不用我说都很清楚。 但是MVC模式在网站发展到一定的程度的时候，会有很多弊端，下边就来说说MVC的一些弊端： 缓存压力在M或C层做缓存，一般在获取不到缓存的时候去数据库或者接口拉数据(下边以去数据库拉数据举例)，然后写入到缓存里。 缓存刺穿。既然使用到缓存，有一个问题是避免不了的，缓存刺穿；缓存一旦被刺穿，那么DB的压力将变得很大，系统的响应也会受到影响。 缓存设置出错。判断是否有缓存的时候，很多人都喜欢判断这个key的值是否为空，如果为空，那么就去拿数据，写缓存。 ```php$value = getMemcache($key);if (empty($value)) {$value = …//取数据setMemcache($value);}``` 相信很多人都会有写这样的方法。虽然可以在getMemcache跟if判断做好协议（比如无缓存的时候返回null，判断的时候只有等于null的时候才判定为无缓存），但不可避免，这个协议的值会被使用到（别人接口的值不可控）。所以这种也有很大机率造成系统的压力加大。 缓存故障。无论使用哪一种缓存，都不能避免缓存会down机。不管是缓存软件问题还是网络、机器问题，这都机率出问题。一旦出问题，那么缓存就失效，DB的压力就上来了，系统就会受到影响。 缓存重启。缓存开始使用或者重启的时候，都会没有缓存，那么不可避免数据全都要去DB里拿，那么这个瞬间DB的压力会爆增，系统的响应肯定也会慢，如果是有大量访问，很有可能系统会响应不过来，使得整个系统垮了。 在一些访问量还算大的应用里，这些缓存问题可能并不明显，一旦访问量上去的时候，缓存就可能出现各种问题。在MC层调缓存，相当于自己做生产者又做消费者，很容易失去平衡。 业务膨胀 业务修改。 第三方数据。当网站就会有很多关，于第三方的接口数据增加进 那么就以www.huya.com这个网站来说说对网站的优化。 原则按应用按页面按模块我们将它动态化，通过JAVA Worker把数据存到KV存储里 静态化思想，是把数据做的静态化，而没有把页面静态化。 异步加载的服务非常多。 监控，监控每个服务的服务质量；（监控数据情况）","link":"/2015/06/01/huya/"},{"title":"Markdown语法说明","text":"Markdown 文件 NOTE: This is Traditional Chinese Edition Document of Markdown Syntax. If you are seeking for English Edition Document. Please refer to Markdown: Syntax. Markdown: Syntax 概述 哲學 行內 HTML 特殊字元自動轉換 區塊元素 段落和換行 標題 區塊引言 清單 程式碼區塊 分隔線 區段元素 連結 強調 程式碼 圖片 其它 跳脫字元 自動連結 感謝 注意：這份文件是用 Markdown 寫的，你可以看看它的原始檔 。 概述 哲學 Markdown 的目標是實現「易讀易寫」。 不過最需要強調的便是它的可讀性。一份使用 Markdown 格式撰寫的文件應該可以直接以純文字發佈，並且看起來不會像是由許多標籤或是格式指令所構成。Markdown 語法受到一些既有 text-to-HTML 格式的影響，包括 [Setext] 1、[atx] 2、[Textile] 3、[reStructuredText] 4、[Grutatext] 5 和 [EtText] 6，然而最大靈感來源其實是純文字的電子郵件格式。 因此 Markdown 的語法全由標點符號所組成，並經過嚴謹慎選，是為了讓它們看起來就像所要表達的意思。像是在文字兩旁加上星號，看起來就像*強調*。Markdown 的清單看起來，嗯，就是清單。假如你有使用過電子郵件，區塊引言看起來就真的像是引用一段文字。 行內 HTML Markdown 的語法有個主要的目的：用來作為一種網路內容的寫作用語言。 Markdown 不是要來取代 HTML，甚至也沒有要和它相似，它的語法種類不多，只和 HTML 的一部分有關係，重點不是要創造一種更容易寫作 HTML 文件的語法，我認為 HTML 已經很容易寫了，Markdown 的重點在於，它能讓文件更容易閱讀、編寫。HTML 是一種發佈的格式，Markdown 是一種編寫的格式，因此，Markdown 的格式語法只涵蓋純文字可以涵蓋的範圍。 不在 Markdown 涵蓋範圍之外的標籤，都可以直接在文件裡面用 HTML 撰寫。不需要額外標註這是 HTML 或是 Markdown；只要直接加標籤就可以了。 只有區塊元素──比如 &lt;div&gt;、&lt;table&gt;、&lt;pre&gt;、&lt;p&gt; 等標籤，必須在前後加上空行，以利與內容區隔。而且這些（元素）的開始與結尾標籤，不可以用 tab 或是空白來縮排。Markdown 的產生器有智慧型判斷，可以避免在區塊標籤前後加上沒有必要的 &lt;p&gt; 標籤。 舉例來說，在 Markdown 文件裡加上一段 HTML 表格： 123456789This is a regular paragraph.&lt;table&gt; &lt;tr&gt; &lt;td&gt;Foo&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt;This is another regular paragraph. 請注意，Markdown 語法在 HTML 區塊標籤中將不會被進行處理。例如，你無法在 HTML 區塊內使用 Markdown 形式的*強調*。 HTML 的區段標籤如 &lt;span&gt;、&lt;cite&gt;、&lt;del&gt; 則不受限制，可以在 Markdown 的段落、清單或是標題裡任意使用。依照個人習慣，甚至可以不用Markdown 格式，而採用 HTML 標籤來格式化。舉例說明：如果比較喜歡 HTML 的 &lt;a&gt; 或 &lt;img&gt; 標籤，可以直接使用這些標籤，而不用 Markdown 提供的連結或是影像標示語法。 HTML 區段標籤和區塊標籤不同，在區段標籤的範圍內， Markdown 的語法是有效的。 特殊字元自動轉換 在 HTML 文件中，有兩個字元需要特殊處理： &lt; 和 &amp; 。 &lt; 符號用於起始標籤，&amp; 符號則用於標記 HTML 實體，如果你只是想要使用這些符號，你必須要使用實體的形式，像是 &amp;lt; 和 &amp;amp;。 &amp; 符號其實很容易讓寫作網路文件的人感到困擾，如果你要打「AT&amp;T」 ，你必須要寫成「AT&amp;amp;T」 ，還得轉換網址內的 &amp; 符號，如果你要連結到： 1http://images.google.com/images?num=30&amp;q=larry+bird 你必須要把網址轉成： 1http://images.google.com/images?num=30&amp;amp;q=larry+bird 才能放到連結標籤的 href 屬性裡。不用說也知道這很容易忘記，這也可能是 HTML 標準檢查所檢查到的錯誤中，數量最多的。 Markdown 允許你直接使用這些符號，但是你要小心跳脫字元的使用，如果你是在HTML 實體中使用 &amp; 符號的話，它不會被轉換，而在其它情形下，它則會被轉換成 &amp;amp;。所以你如果要在文件中插入一個著作權的符號，你可以這樣寫： 1&amp;copy; Markdown 將不會對這段文字做修改，但是如果你這樣寫： 1AT&amp;T Markdown 就會將它轉為： 1AT&amp;amp;T 類似的狀況也會發生在 &lt; 符號上，因為 Markdown 支援 行內 HTML ，如果你是使用 &lt; 符號作為 HTML 標籤使用，那 Markdown 也不會對它做任何轉換，但是如果你是寫： 14 &lt; 5 Markdown 將會把它轉換為： 14 &amp;lt; 5 不過需要注意的是，code 範圍內，不論是行內還是區塊， &lt; 和 &amp; 兩個符號都一定會被轉換成 HTML 實體，這項特性讓你可以很容易地用 Markdown 寫 HTML code （和 HTML 相對而言， HTML 語法中，你要把所有的 &lt; 和 &amp; 都轉換為 HTML 實體，才能在 HTML 文件裡面寫出 HTML code。） 區塊元素 段落和換行 一個段落是由一個以上相連接的行句組成，而一個以上的空行則會切分出不同的段落（空行的定義是顯示上看起來像是空行，便會被視為空行。比方說，若某一行只包含空白和 tab，則該行也會被視為空行），一般的段落不需要用空白或斷行縮排。 「一個以上相連接的行句組成」這句話其實暗示了 Markdown 允許段落內的強迫斷行，這個特性和其他大部分的 text-to-HTML 格式不一樣（包括 MovableType 的「Convert Line Breaks」選項），其它的格式會把每個斷行都轉成 &lt;br /&gt; 標籤。 如果你真的想要插入 &lt;br /&gt; 標籤的話，在行尾加上兩個以上的空白，然後按 enter。 是的，這確實需要花比較多功夫來插入 &lt;br /&gt; ，但是「每個換行都轉換為 &lt;br /&gt;」的方法在 Markdown 中並不適合， Markdown 中 email 式的 區塊引言 和多段落的 清單 在使用換行來排版的時候，不但更好用，還更好閱讀。 標題 Markdown 支援兩種標題的語法，[Setext] 1 和 [atx] 2 形式。 Setext 形式是用底線的形式，利用 = （最高階標題）和 - （第二階標題），例如： 12345This is an H1=============This is an H2------------- 任何數量的 = 和 - 都可以有效果。 Atx 形式則是在行首插入 1 到 6 個 # ，對應到標題 1 到 6 階，例如： 12345# This is an H1## This is an H2###### This is an H6 你可以選擇性地「關閉」atx 樣式的標題，這純粹只是美觀用的，若是覺得這樣看起來比較舒適，你就可以在行尾加上 #，而行尾的 # 數量也不用和開頭一樣（行首的井字數量決定標題的階數）： 12345# This is an H1 ### This is an H2 ##### This is an H3 ###### Blockquotes Markdown 使用 email 形式的區塊引言，如果你很熟悉如何在 email 信件中引言，你就知道怎麼在 Markdown 文件中建立一個區塊引言，那會看起來像是你強迫斷行，然後在每行的最前面加上 &gt; ： 123456&gt; This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,&gt; consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.&gt; Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.&gt; &gt; Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse&gt; id sem consectetuer libero luctus adipiscing. Markdown 也允許你只在整個段落的第一行最前面加上 &gt; ： 123456&gt; This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.&gt; Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisseid sem consectetuer libero luctus adipiscing. 區塊引言可以有階層（例如：引言內的引言），只要根據層數加上不同數量的 &gt; ： 12345&gt; This is the first level of quoting.&gt;&gt; &gt; This is nested blockquote.&gt;&gt; Back to the first level. 引言的區塊內也可以使用其他的 Markdown 語法，包括標題、清單、程式碼區塊等： 12345678&gt; ## This is a header.&gt; &gt; 1. This is the first list item.&gt; 2. This is the second list item.&gt; &gt; Here&apos;s some example code:&gt; &gt; return shell_exec(&quot;echo $input | $markdown_script&quot;); 任何標準的文字編輯器都能簡單地建立 email 樣式的引言，例如 BBEdit ，你可以選取文字後然後從選單中選擇增加引言階層。 清單 Markdown 支援有序清單和無序清單。 無序清單使用星號、加號或是減號作為清單標記： 123* Red* Green* Blue 等同於： 123+ Red+ Green+ Blue 也等同於： 123- Red- Green- Blue 有序清單則使用數字接著一個英文句點： 1231. Bird2. McHale3. Parish 很重要的一點是，你在清單標記上使用的數字並不會影響輸出的 HTML 結果，上面的清單所產生的 HTML 標記為： 12345&lt;ol&gt;&lt;li&gt;Bird&lt;/li&gt;&lt;li&gt;McHale&lt;/li&gt;&lt;li&gt;Parish&lt;/li&gt;&lt;/ol&gt; 如果你的清單標記寫成： 1231. Bird1. McHale1. Parish 或甚至是： 1233. Bird1. McHale8. Parish 你都會得到完全相同的 HTML 輸出。重點在於，你可以讓 Markdown 文件的清單數字和輸出的結果相同，或是你懶一點，你可以完全不用在意數字的正確性。 如果你使用懶惰的寫法，建議第一個項目最好還是從 1. 開始，因為 Markdown 未來可能會支援有序清單的 start 屬性。 清單項目標記通常是放在最左邊，但是其實也可以縮排，最多三個空白，項目標記後面則一定要接著至少一個空白或 tab。 要讓清單看起來更漂亮，你可以把內容用固定的縮排整理好： 12345* Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus. Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.* Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse id sem consectetuer libero luctus adipiscing. 但是如果你很懶，那也不一定需要： 12345* Lorem ipsum dolor sit amet, consectetuer adipiscing elit.Aliquam hendrerit mi posuere lectus. Vestibulum enim wisi,viverra nec, fringilla in, laoreet vitae, risus.* Donec sit amet nisl. Aliquam semper ipsum sit amet velit.Suspendisse id sem consectetuer libero luctus adipiscing. 如果清單項目間用空行分開， Markdown 會把項目的內容在輸出時用 &lt;p&gt; 標籤包起來，舉例來說： 12* Bird* Magic 會被轉換為： 1234&lt;ul&gt;&lt;li&gt;Bird&lt;/li&gt;&lt;li&gt;Magic&lt;/li&gt;&lt;/ul&gt; 但是這個： 123* Bird* Magic 會被轉換為： 1234&lt;ul&gt;&lt;li&gt;&lt;p&gt;Bird&lt;/p&gt;&lt;/li&gt;&lt;li&gt;&lt;p&gt;Magic&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt; 清單項目可以包含多個段落，每個項目下的段落都必須縮排 4 個空白或是一個 tab ： 1234567891. This is a list item with two paragraphs. Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus. Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus. Donec sit amet nisl. Aliquam semper ipsum sit amet velit.2. Suspendisse id sem consectetuer libero luctus adipiscing. 如果你每行都有縮排，看起來會看好很多，當然，再次地，如果你很懶惰，Markdown 也允許： 1234567* This is a list item with two paragraphs. This is the second paragraph in the list item. You&apos;reonly required to indent the first line. Lorem ipsum dolorsit amet, consectetuer adipiscing elit.* Another item in the same list. 如果要在清單項目內放進引言，那 &gt; 就需要縮排： 1234* A list item with a blockquote: &gt; This is a blockquote &gt; inside a list item. 如果要放程式碼區塊的話，該區塊就需要縮排兩次，也就是 8 個空白或是兩個 tab： 123* A list item with a code block: &lt;code goes here&gt; 當然，項目清單很可能會不小心產生，像是下面這樣的寫法： 11986. What a great season. 換句話說，也就是在行首出現數字-句點-空白，要避免這樣的狀況，你可以在句點前面加上反斜線。 11986\\. What a great season. 程式碼區塊 和程式相關的寫作或是標籤語言原始碼通常會有已經排版好的程式碼區塊，通常這些區塊我們並不希望它以一般段落文件的方式去排版，而是照原來的樣子顯示，Markdown 會用 &lt;pre&gt; 和 &lt;code&gt; 標籤來把程式碼區塊包起來。 要在 Markdown 中建立程式碼區塊很簡單，只要簡單地縮排 4 個空白或是 1 個 tab 就可以，例如，下面的輸入： 123This is a normal paragraph: This is a code block. Markdown 會轉換成： 1234&lt;p&gt;This is a normal paragraph:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;This is a code block.&lt;/code&gt;&lt;/pre&gt; 這個每行一階的縮排（4 個空白或是 1 個 tab），都會被移除，例如： 12345Here is an example of AppleScript: tell application &quot;Foo&quot; beep end tell 會被轉換為： 123456&lt;p&gt;Here is an example of AppleScript:&lt;/p&gt;&lt;pre&gt;&lt;code&gt;tell application &quot;Foo&quot; beepend tell&lt;/code&gt;&lt;/pre&gt; 一個程式碼區塊會一直持續到沒有縮排的那一行（或是文件結尾）。 在程式碼區塊裡面， &amp; 、 &lt; 和 &gt; 會自動轉成 HTML 實體，這樣的方式讓你非常容易使用 Markdown 插入範例用的 HTML 原始碼，只需要複製貼上，再加上縮排就可以了，剩下的 Markdown 都會幫你處理，例如： 123&lt;div class=&quot;footer&quot;&gt; &amp;copy; 2004 Foo Corporation&lt;/div&gt; 會被轉換為： 1234&lt;pre&gt;&lt;code&gt;&amp;lt;div class=&quot;footer&quot;&amp;gt; &amp;amp;copy; 2004 Foo Corporation&amp;lt;/div&amp;gt;&lt;/code&gt;&lt;/pre&gt; 程式碼區塊中，一般的 Markdown 語法不會被轉換，像是星號便只是星號，這表示你可以很容易地以 Markdown 語法撰寫 Markdown 語法相關的文件。 分隔線 你可以在一行中用三個或以上的星號、減號、底線來建立一個分隔線，行內不能有其他東西。你也可以在星號中間插入空白。下面每種寫法都可以建立分隔線： 123456789* * *********- - ---------------------------------------- 區段元素 連結 Markdown 支援兩種形式的連結語法： 行內和參考兩種形式。 不管是哪一種，連結的文字都是用 [方括號] 來標記。 要建立一個行內形式的連結，只要在方塊括號後面馬上接著括號並插入網址連結即可，如果你還想要加上連結的 title 文字，只要在網址後面，用雙引號把 title 文字包起來即可，例如： 123This is [an example](http://example.com/ &quot;Title&quot;) inline link.[This link](http://example.net/) has no title attribute. 會產生： 12345&lt;p&gt;This is &lt;a href=&quot;http://example.com/&quot; title=&quot;Title&quot;&gt;an example&lt;/a&gt; inline link.&lt;/p&gt;&lt;p&gt;&lt;a href=&quot;http://example.net/&quot;&gt;This link&lt;/a&gt; has notitle attribute.&lt;/p&gt; 如果你是要連結到同樣主機的資源，你可以使用相對路徑： 1See my [About](/about/) page for details. 參考形式的連結使用另外一個方括號接在連結文字的括號後面，而在第二個方括號裡面要填入用以辨識連結的標籤： 1This is [an example][id] reference-style link. 你也可以選擇性地在兩個方括號中間加上空白： 1This is [an example] [id] reference-style link. 接著，在文件的任意處，你可以把這個標籤的連結內容定義出來： 1[id]: http://example.com/ &quot;Optional Title Here&quot; 連結定義的形式為： 方括號，裡面輸入連結的辨識用標籤 接著一個冒號 接著一個以上的空白或 tab 接著連結的網址 選擇性地接著 title 內容，可以用單引號、雙引號或是括弧包著 下面這三種連結的定義都是相同： 123[foo]: http://example.com/ &quot;Optional Title Here&quot;[foo]: http://example.com/ &apos;Optional Title Here&apos;[foo]: http://example.com/ (Optional Title Here) 請注意：有一個已知的問題是 Markdown.pl 1.0.1 會忽略單引號包起來的連結 title。 連結網址也可以用方括號包起來： 1[id]: &lt;http://example.com/&gt; &quot;Optional Title Here&quot; 你也可以把 title 屬性放到下一行，也可以加一些縮排，網址太長的話，這樣會比較好看： 12[id]: http://example.com/longish/path/to/resource/here &quot;Optional Title Here&quot; 網址定義只有在產生連結的時候用到，並不會直接出現在文件之中。 連結辨識標籤可以有字母、數字、空白和標點符號，但是並不區分大小寫，因此下面兩個連結是一樣的： 12[link text][a][link text][A] 預設的連結標籤功能讓你可以省略指定連結標籤，這種情形下，連結標籤和連結文字會視為相同，要用預設連結標籤只要在連結文字後面加上一個空的方括號，如果你要讓 “Google” 連結到 google.com，你可以簡化成： 1[Google][] 然後定義連結內容： 1[Google]: http://google.com/ 由於連結文字可能包含空白，所以這種簡化的標籤內也可以包含多個文字： 1Visit [Daring Fireball][] for more information. 然後接著定義連結： ​ 1[Daring Fireball]: http://daringfireball.net/ 連結的定義可以放在文件中的任何一個地方，我比較偏好直接放在連結出現段落的後面，你也可以把它放在文件最後面，就像是註解一樣。 下面是一個參考式連結的範例： 123456I get 10 times more traffic from [Google] [1] than from[Yahoo] [2] or [MSN] [3]. [1]: http://google.com/ &quot;Google&quot; [2]: http://search.yahoo.com/ &quot;Yahoo Search&quot; [3]: http://search.msn.com/ &quot;MSN Search&quot; 如果改成用連結名稱的方式寫： 123456I get 10 times more traffic from [Google][] than from[Yahoo][] or [MSN][]. [google]: http://google.com/ &quot;Google&quot; [yahoo]: http://search.yahoo.com/ &quot;Yahoo Search&quot; [msn]: http://search.msn.com/ &quot;MSN Search&quot; 上面兩種寫法都會產生下面的 HTML。 1234&lt;p&gt;I get 10 times more traffic from &lt;a href=&quot;http://google.com/&quot;title=&quot;Google&quot;&gt;Google&lt;/a&gt; than from&lt;a href=&quot;http://search.yahoo.com/&quot; title=&quot;Yahoo Search&quot;&gt;Yahoo&lt;/a&gt;or &lt;a href=&quot;http://search.msn.com/&quot; title=&quot;MSN Search&quot;&gt;MSN&lt;/a&gt;.&lt;/p&gt; 下面是用行內形式寫的同樣一段內容的 Markdown 文件，提供作為比較之用： 123I get 10 times more traffic from [Google](http://google.com/ &quot;Google&quot;)than from [Yahoo](http://search.yahoo.com/ &quot;Yahoo Search&quot;) or[MSN](http://search.msn.com/ &quot;MSN Search&quot;). 參考式的連結其實重點不在於它比較好寫，而是它比較好讀，比較一下上面的範例，使用參考式的文章本身只有 81 個字元，但是用行內形式的連結卻會增加到 176 個字元，如果是用純 HTML 格式來寫，會有 234 個字元，在 HTML 格式中，標籤比文字還要多。 使用 Markdown 的參考式連結，可以讓文件更像是瀏覽器最後產生的結果，讓你可以把一些標記相關的資訊移到段落文字之外，你就可以增加連結而不讓文章的閱讀感覺被打斷。 強調 Markdown 使用星號（*）和底線（_）作為標記強調字詞的符號，被 * 或 _ 包圍的字詞會被轉成用 &lt;em&gt; 標籤包圍，用兩個 * 或 _ 包起來的話，則會被轉成 &lt;strong&gt;，例如： 1234567*single asterisks*_single underscores_**double asterisks**__double underscores__ 會轉成： 1234567&lt;em&gt;single asterisks&lt;/em&gt;&lt;em&gt;single underscores&lt;/em&gt;&lt;strong&gt;double asterisks&lt;/strong&gt;&lt;strong&gt;double underscores&lt;/strong&gt; 你可以隨便用你喜歡的樣式，唯一的限制是，你用什麼符號開啟標籤，就要用什麼符號結束。 強調也可以直接插在文字中間： 1un*frigging*believable 但是如果你的 * 和 _ 兩邊都有空白的話，它們就只會被當成普通的符號。 如果要在文字前後直接插入普通的星號或底線，你可以用反斜線： 1\\*this text is surrounded by literal asterisks\\* 程式碼 如果要標記一小段行內程式碼，你可以用反引號把它包起來（`），例如： 1Use the `printf()` function. 會產生： 1&lt;p&gt;Use the &lt;code&gt;printf()&lt;/code&gt; function.&lt;/p&gt; 如果要在程式碼區段內插入反引號，你可以用多個反引號來開啟和結束程式碼區段： 1``There is a literal backtick (`) here.`` 這段語法會產生： 1&lt;p&gt;&lt;code&gt;There is a literal backtick (`) here.&lt;/code&gt;&lt;/p&gt; 程式碼區段的起始和結束端都可以放入一個空白，起始端後面一個，結束端前面一個，這樣你就可以在區段的一開始就插入反引號： 1A single backtick in a code span: `` ` `` ​ 1A backtick-delimited string in a code span: `` `foo` `` 會產生： 1&lt;p&gt;A single backtick in a code span: &lt;code&gt;`&lt;/code&gt;&lt;/p&gt; ​ 1&lt;p&gt;A backtick-delimited string in a code span: &lt;code&gt;`foo`&lt;/code&gt;&lt;/p&gt; 在程式碼區段內，&amp; 和方括號都會被轉成 HTML 實體，這樣會比較容易插入 HTML 原始碼，Markdown 會把下面這段： 1Please don&apos;t use any `&lt;blink&gt;` tags. 轉為： 1&lt;p&gt;Please don&apos;t use any &lt;code&gt;&amp;lt;blink&amp;gt;&lt;/code&gt; tags.&lt;/p&gt; 你也可以這樣寫： 1`&amp;#8212;` is the decimal-encoded equivalent of `&amp;mdash;`. 以產生： 12&lt;p&gt;&lt;code&gt;&amp;amp;#8212;&lt;/code&gt; is the decimal-encodedequivalent of &lt;code&gt;&amp;amp;mdash;&lt;/code&gt;.&lt;/p&gt; 圖片 很明顯地，要在純文字應用中設計一個 「自然」的語法來插入圖片是有一定難度的。 Markdown 使用一種和連結很相似的語法來標記圖片，同樣也允許兩種樣式： 行內和參考。 行內圖片的語法看起來像是： 123![Alt text](/path/to/img.jpg)![Alt text](/path/to/img.jpg &quot;Optional title&quot;) 詳細敘述如下： 一個驚嘆號 ! 接著一個方括號，裡面放上圖片的替代文字 接著一個普通括號，裡面放上圖片的網址，最後還可以用引號包住並加上 選擇性的 ‘title’ 文字。 參考式的圖片語法則長得像這樣： 1![Alt text][id] 「id」是圖片參考的名稱，圖片參考的定義方式則和連結參考一樣： 1[id]: url/to/image &quot;Optional title attribute&quot; 到目前為止， Markdown 還沒有辦法指定圖片的寬高，如果你需要的話，你可以使用普通的 &lt;img&gt; 標籤。 其它 自動連結 Markdown 支援比較簡短的自動連結形式來處理網址和電子郵件信箱，只要是用方括號包起來， Markdown 就會自動把它轉成連結，連結的文字就和連結位置一樣，例如： 1&lt;http://example.com/&gt; Markdown 會轉為： 1&lt;a href=&quot;http://example.com/&quot;&gt;http://example.com/&lt;/a&gt; 自動的郵件連結也很類似，只是 Markdown 會先做一個編碼轉換的過程，把文字字元轉成 16 進位碼的 HTML 實體，這樣的格式可以混淆一些不好的信箱地址收集機器人，例如： 1&lt;address@example.com&gt; Markdown 會轉成： 1234&lt;a href=&quot;&amp;#x6D;&amp;#x61;i&amp;#x6C;&amp;#x74;&amp;#x6F;:&amp;#x61;&amp;#x64;&amp;#x64;&amp;#x72;&amp;#x65;&amp;#115;&amp;#115;&amp;#64;&amp;#101;&amp;#120;&amp;#x61;&amp;#109;&amp;#x70;&amp;#x6C;e&amp;#x2E;&amp;#99;&amp;#111;&amp;#109;&quot;&gt;&amp;#x61;&amp;#x64;&amp;#x64;&amp;#x72;&amp;#x65;&amp;#115;&amp;#115;&amp;#64;&amp;#101;&amp;#120;&amp;#x61;&amp;#109;&amp;#x70;&amp;#x6C;e&amp;#x2E;&amp;#99;&amp;#111;&amp;#109;&lt;/a&gt; 在瀏覽器裡面，這段字串會變成一個可以點擊的「address@example.com」連結。 （這種作法雖然可以混淆不少的機器人，但並無法全部擋下來，不過這樣也比什麼都不做好些。無論如何，公開你的信箱終究會引來廣告信件的。） 跳脫字元 Markdown 可以利用反斜線來插入一些在語法中有其它意義的符號，例如：如果你想要用星號加在文字旁邊的方式來做出強調效果（但不用 &lt;em&gt; 標籤），你可以在星號的前面加上反斜線： 1\\*literal asterisks\\* Markdown 支援在下面這些符號前面加上反斜線來幫助插入普通的符號： 123456789101112\\ 反斜線` 反引號* 星號_ 底線{} 大括號[] 方括號() 括號# 井字號+ 加號- 減號. 英文句點! 驚嘆號 感謝 感謝 leafy7382 協助翻譯，hlb、Randylien 幫忙潤稿，ethantw 的漢字標準格式?CSS Reset， WM 回報文字錯誤。","link":"/2014/10/21/syntax/"},{"title":"JVM工作原理","text":"Java 虚拟机 Java 虚拟机（Java virtual machine，JVM）是运行 Java 程序必不可少的机制。JVM实现了Java语言最重要的特征：即平台无关性。原理：编译后的 Java 程序指令并不直接在硬件系统的 CPU 上执行，而是由 JVM 执行。JVM屏蔽了与具体平台相关的信息，使Java语言编译程序只需要生成在JVM上运行的目标字节码（.class）,就可以在多种平台上不加修改地运行。Java 虚拟机在执行字节码时，把字节码解释成具体平台上的机器指令执行。因此实现java平台无关性。它是 Java 程序能在多平台间进行无缝移植的可靠保证，同时也是 Java 程序的安全检验引擎（还进行安全检查）。 JVM 是 编译后的 Java 程序（.class文件）和硬件系统之间的接口 （ 编译后：javac 是收录于 JDK 中的 Java 语言编译器。该工具可以将后缀名为. java 的源文件编译为后缀名为. class 的可以运行于 Java 虚拟机的字节码。） JVM architecture: 图片摘自 http://javapapers.com/java/java-garbage-collection-introduction/ JVM = 类加载器 classloader + 执行引擎 execution engine + 运行时数据区域 runtime data areaclassloader 把硬盘上的class 文件加载到JVM中的运行时数据区域, 但是它不负责这个类文件能否执行，而这个是 执行引擎 负责的。 ClassLoader作用：装载.class文件classloader 有两种装载class的方式 （时机）： 隐式：运行过程中，碰到new方式生成对象时，隐式调用classLoader到JVM 显式：通过class.forname()动态加载 双亲委派模型（Parent Delegation Model）：类的加载过程采用双亲委托机制，这种机制能更好的保证 Java 平台的安全。该模型要求除了顶层的Bootstrap class loader启动类加载器外，其余的类加载器都应当有自己的父类加载器。子类加载器和父类加载器不是以继承（Inheritance）的关系来实现，而是通过组合（Composition）关系来复用父加载器的代码。每个类加载器都有自己的命名空间（由该加载器及所有父类加载器所加载的类组成，在同一个命名空间中，不会出现类的完整名字（包括类的包名）相同的两个类；在不同的命名空间中，有可能会出现类的完整名字（包括类的包名）相同的两个类） 双亲委派模型的工作过程为： 当前 ClassLoader 首先从自己已经加载的类中查询是否此类已经加载，如果已经加载则直接返回原来已经加载的类。 每个类加载器都有自己的加载缓存，当一个类被加载了以后就会放入缓存，等下次加载的时候就可以直接返回了。 当前 classLoader 的缓存中没有找到被加载的类的时候，委托父类加载器去加载，父类加载器采用同样的策略，首先查看自己的缓存，然后委托父类的父类去加载，一直到 bootstrap ClassLoader. 当所有的父类加载器都没有加载的时候，再由当前的类加载器加载，并将其放入它自己的缓存中，以便下次有加载请求的时候直接返回。 使用这种模型来组织类加载器之间的关系的好处:主要是为了安全性，避免用户自己编写的类动态替换 Java 的一些核心类，比如 String，同时也避免了重复加载，因为 JVM 中区分不同类，不仅仅是根据类名，相同的 class 文件被不同的 ClassLoader 加载就是不同的两个类，如果相互转型的话会抛java.lang.ClassCaseException. 类加载器 classloader 是具有层次结构的，也就是父子关系。其中，Bootstrap 是所有类加载器的父亲。如下图所示：Bootstrap class loader： 父类当运行 java 虚拟机时，这个类加载器被创建，它负责加载虚拟机的核心类库，如 java.lang.* 等。例如 java.lang.Object 就是由根类加载器加载的。需要注意的是，这个类加载器不是用 java 语言写的，而是用 C/C++ 写的。Extension class loader:这个加载器加载出了基本 API 之外的一些拓展类。AppClass Loader:加载应用程序和程序员自定义的类。 除了以上虚拟机自带的加载器以外，用户还可以定制自己的类加载器（User-defined Class Loader）。Java 提供了抽象类 java.lang.ClassLoader，所有用户自定义的类加载器应该继承 ClassLoader 类。 这是JVM分工自治生态系统的一个很好的体现。 http://www.importnew.com/6581.html 执行引擎作用： 执行字节码，或者执行本地方法 Runtime Data AreaJVM 运行时数据区 (JVM Runtime Area) 其实就是指 JVM 在运行期间，其对JVM内存空间的划分和分配。JVM在运行时将数据划分为了6个区域来存储。 程序员写的所有程序都被加载到运行时数据区域中，不同类别存放在heap, java stack, native method stack, PC register, method area. 下面对各个部分的功能和存储的内容进行描述： PC程序计数器：一块较小的内存空间，可以看做是当前线程所执行的字节码的行号指示器, NAMELY存储每个线程下一步将执行的JVM指令，如该方法为native的，则PC寄存器中不存储任何信息。Java 的多线程机制离不开程序计数器，每个线程都有一个自己的PC，以便完成不同线程上下文环境的切换。 java虚拟机栈：与 PC 一样，java 虚拟机栈也是线程私有的。每一个 JVM 线程都有自己的 java 虚拟机栈，这个栈与线程同时创建，它的生命周期与线程相同。虚拟机栈描述的是Java 方法执行的内存模型：每个方法被执行的时候都会同时创建一个栈帧（Stack Frame）用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法被调用直至执行完成的过程就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。 本地方法栈：与虚拟机栈的作用相似，虚拟机栈为虚拟机执行执行java方法服务，而本地方法栈则为虚拟机使用到的本地方法服务。 Java堆：被所有线程共享的一块存储区域，在虚拟机启动时创建，它是JVM用来存储对象实例以及数组值的区域，可以认为Java中所有通过new创建的对象的内存都在此分配。 Java堆在JVM启动的时候就被创建，堆中储存了各种对象，这些对象被自动管理内存系统（Automatic Storage Management System，也即是常说的 “Garbage Collector（垃圾回收器）”）所管理。这些对象无需、也无法显示地被销毁。 JVM将Heap分为两块：新生代New Generation和旧生代Old Generation Note: 堆在JVM是所有线程共享的，因此在其上进行对象内存的分配均需要进行加锁，这也是new开销比较大的原因。 鉴于上面的原因，Sun Hotspot JVM为了提升对象内存分配的效率，对于所创建的线程都会分配一块独立的空间，这块空间又称为TLAB TLAB仅作用于新生代的Eden Space，因此在编写Java程序时，通常多个小的对象比大的对象分配起来更加高效 方法区方法区和堆区域一样，是各个线程共享的内存区域，它用于存储每一个类的结构信息，例如运行时常量池，成员变量和方法数据，构造函数和普通函数的字节码内容，还包括一些在类、实例、接口初始化时用到的特殊方法。当开发人员在程序中通过Class对象中的getName、isInstance等方法获取信息时，这些数据都来自方法区。 方法区也是全局共享的，在虚拟机启动时候创建。在一定条件下它也会被GC。这块区域对应Permanent Generation 持久代。 XX：PermSize指定大小。 运行时常量池 其空间从方法区中分配，存放的为类中固定的常量信息、方法和域的引用信息。 GC javapapersJava garbage collection is an automatic process to manage the runtime memory used by programs. By doing it automatic JVM relieves the programmer of the overhead of assigning and freeing up memory resources in a program.java 与 C语言相比的一个优势是，可以通过自己的JVM自动分配和回收内存空间。 何为GC？垃圾回收机制是由垃圾收集器Garbage Collection GC来实现的，GC是后台的守护进程。它的特别之处是它是一个低优先级进程，但是可以根据内存的使用情况动态的调整他的优先级。因此，它是在内存中低到一定限度时才会自动运行，从而实现对内存的回收。这就是垃圾回收的时间不确定的原因。 为何要这样设计：因为GC也是进程，也要消耗CPU等资源，如果GC执行过于频繁会对java的程序的执行产生较大的影响（java解释器本来就不快），因此JVM的设计者们选着了不定期的gc。 GC有关的是: runtime data area 中的 heap（对象实例会存储在这里） 和 gabage collector方法。 GC为内存中不再使用的对象进行回收，GC中调用回收的方法–收集器garbage collector. 由于GC要消耗一些资源和时间，Java 在对对象的生命周期特征（eden or survivor）进行分析之后，采用了分代的方式进行对象的收集，以缩短GC对应用造成的暂停。 在垃圾回收器回收内存之前，还需要一些清理工作。因为垃圾回收gc只能回收通过new关键字申请的内存（在堆上），但是堆上的内存并不完全是通过new申请分配的。还有一些本地方法（一般是调用的C方法）。这部分“特殊的内存”如果不手动释放，就会导致内存泄露，gc是无法回收这部分内存的。所以需要在finalize中用本地方法(native method)如free操作等，再使用gc方法。显示的GC方法是system.gc() 垃圾回收技术方法一：引用计数法。简单但速度很慢。缺陷是：不能处理循环引用的情况。方法二：停止-复制(stop and copy)。效率低，需要的空间大，优点，不会产生碎片。方法三：标记 - 清除算法 (mark and sweep)。速度较快，占用空间少，标记清除后会产生大量的碎片。 JAVA虚拟机中是如何做的？ java的做法很聪明，我们称之为”自适应”的垃圾回收器，或者是”自适应的、分代的、停止-复制、标记-清扫”式垃圾回收器。它会根据不同的环境和需要选择不同的处理方式。 heap组成由于GC需要消耗一些资源和时间的，Java在对对象的生命周期特征进行分析后，采用了分代的方式来进行对象的收集，即按照新生代、旧生代的方式来对对象进行收集，以尽可能的缩短GC对应用造成的暂停. 由于GC需要消耗一些资源和时间的，Java在对对象的生命周期特征进行分析后，采用了分代的方式来进行对象的收集，即按照新生代、旧生代的方式来对对象进行收集，以尽可能的缩短GC对应用造成的暂停.heap 的组成有三区域/世代：(可以理解随着时间，对象实例不断变换heap中的等级，有点像年级) 新生代 Young Generation Eden Space 任何新进入运行时数据区域的实例都会存放在此 S0 Suvivor Space 存在时间较长，经过垃圾回收没有被清除的实例，就从Eden 搬到了S0 S1 Survivor Space 同理，存在时间更长的实例，就从S0 搬到了S1 旧生代 Old Generation/tenured 旧生代 Old Generation/tenured同理，存在时间更长的实例，对象多次回收没被清除，就从S1 搬到了tenured Perm 存放运行时数据区的方法区 Java 不同的世代使用不同的 GC 算法。 Minor collection： 新生代 Young Generation 使用将 Eden 还有 Survivor 内的数据利用 semi-space 做复制收集（Copying collection）， 并将原本 Survivor 内经过多次垃圾收集仍然存活的对象移动到 Tenured。 Major collection 则会进行 Minor collection，Tenured 世代则进行标记压缩收集。 To note that:这个搬运工作都是GC 完成的，这也是garbage collector 的名字来源，而不是叫garbage cleaner. GC负责在heap中搬运实例，以及收回存储空间。 GC工作原理JVM 分别对新生代和旧生代采用不同的垃圾回收机制 何为垃圾？Java中那些不可达的对象就会变成垃圾。那么什么叫做不可达？其实就是没有办法再引用到该对象了。主要有以下情况使对象变为垃圾：1.对非线程的对象来说，所有的活动线程都不能访问该对象，那么该对象就会变为垃圾。2.对线程对象来说，满足上面的条件，且线程未启动或者已停止。 例如： 改变对象的引用，如置为null或者指向其他对象。 1234Object x=new Object();//object1 Object y=new Object();//object2 x=y;//object1 变为垃圾 x=y=null;//object2 变为垃圾 超出作用域 123if(i==0){ Object x=new Object();//object1 }//括号结束后object1将无法被引用，变为垃圾 类嵌套导致未完全释放 123456class A{ A a; } A x= new A();//分配一个空间 x.a= new A();//又分配了一个空间 x=null;//将会产生两个垃圾 线程中的垃圾 class A implements Runnable{ void run(){ //.... } } //main A x=new A();//object1 x.start(); x=null;//等线程执行完后object1才被认定为垃圾 这样看，确实在代码执行过程中会产生很多垃圾，不过不用担心，java可以有效地处理他们。","link":"/2015/06/01/jvm/"},{"title":"Facade类分析","text":"Facade类在文档中的介绍是这样说的 Facades 提供一个静态接口给在应用程序的 服务容器 中可以取用的类。Laravel 附带许多 facades，甚至你可能已经在不知情的状况下使用过它们！Laravel 的「facades」作为在 IoC 容器里面的基础类的静态代理，提供的语法有简洁、易表达的优点，同时维持比传统的静态方法更高的可测试性和弹性。 说明可以查看官方文档地址。 但在官方文档里只说Facade是怎么使用，并没有说明这个类是运行情况。 下边就介绍下Facade的工作过程： 新的Facade类在官方文档里已经有介绍了，下边以DB类为例子。 12345678910111213141516171819&lt;?php namespace Illuminate\\Support\\Facades; /** * @see \\Illuminate\\Database\\DatabaseManager *@see \\Illuminate\\Database\\Connection */ class DB extends Facade { /** *Get the registered name of the component. * *@return string */ protected static function getFacadeAccessor() { return 'db'; } } 这里实现了Facade的getFacadeAccessor方法，这个方法的工作是返回服务容器绑定的名称。 那么有一个疑问就是，DB类是怎么通过’db’取出来的。 静态方法加载像DB类，我们这样使用DB::select(…)，面DB类里根本就没有select这个静态方法。 根据PHP这个语言特色，DB::select最终会调用Facade类的__callStatic方法 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&lt;?php /** * Get the root object behind the facade. * * @return mixed */ public static function getFacadeRoot() { return static::resolveFacadeInstance(static::getFacadeAccessor()); } /** * Resolve the facade root instance from the container. * * @param string|object $name * @return mixed */ protected static function resolveFacadeInstance($name) { if (is_object($name)) { return $name; } if (isset(static::$resolvedInstance[$name])) { return static::$resolvedInstance[$name]; } return static::$resolvedInstance[$name] = static::$app[$name]; } /** * Handle dynamic, static calls to the object. * * @param string $method * @param array $args * @return mixed */ public static function __callStatic($method, $args) { $instance = static::getFacadeRoot(); if (! $instance) { throw new RuntimeException('A facade root has not been set.'); } switch (count($args)) { case 0: return $instance-&gt;$method(); case 1: return $instance-&gt;$method($args[0]); case 2: return $instance-&gt;$method($args[0], $args[1]); case 3: return $instance-&gt;$method($args[0], $args[1], $args[2]); case 4: return $instance-&gt;$method($args[0], $args[1], $args[2], $args[3]); default: return call_user_func_array([$instance, $method], $args); } } 从这个方法就可以知道，最开始的时候会先调用getFacadeRoot方法知道，返回的容易最终于还是通过static::$app[$name];返回 Facade的$app参数在Facade并没有加载$app参数的过程，只有一个set的方法 1234567891011&lt;?php /** * Set the application instance. * * @param \\Illuminate\\Contracts\\Foundation\\Application $app * @return void */ public static function setFacadeApplication($app) { static::$app = $app; } 这个setFacadeApplication方法是在类 Illuminate\\Foundation\\Bootstrap\\RegisterFacades方法 bootstrap(Application $app)设置 12345678910111213141516171819202122232425&lt;?phpnamespace Illuminate\\Foundation\\Bootstrap;use Illuminate\\Support\\Facades\\Facade;use Illuminate\\Foundation\\AliasLoader;use Illuminate\\Contracts\\Foundation\\Application;class RegisterFacades{ /** * Bootstrap the given application. * * @param \\Illuminate\\Contracts\\Foundation\\Application $app * @return void */ public function bootstrap(Application $app) { Facade::clearResolvedInstances(); Facade::setFacadeApplication($app); AliasLoader::getInstance($app-&gt;make('config')-&gt;get('app.aliases'))-&gt;register(); }} 页RegisterFacades类载见配置vendor/composer/autoload_classmap.php $app的db加载到了这里，$app设置完了，那么，$app里的db参数是什么时候设置的呢？ $app参数是Illuminate\\Foundation\\Application类，类有一个构造函数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960&lt;?php public function __construct($basePath = null) { $this-&gt;registerBaseBindings(); $this-&gt;registerBaseServiceProviders(); $this-&gt;registerCoreContainerAliases(); if ($basePath) { $this-&gt;setBasePath($basePath); } } public function registerCoreContainerAliases() { $aliases = [ 'app' =&gt; ['Illuminate\\Foundation\\Application', 'Illuminate\\Contracts\\Container\\Container', 'Illuminate\\Contracts\\Foundation\\Application'], 'auth' =&gt; ['Illuminate\\Auth\\AuthManager', 'Illuminate\\Contracts\\Auth\\Factory'], 'auth.driver' =&gt; ['Illuminate\\Contracts\\Auth\\Guard'], 'auth.password' =&gt; ['Illuminate\\Contracts\\Auth\\PasswordBrokerFactory'], 'auth.password.broker' =&gt; ['Illuminate\\Contracts\\Auth\\PasswordBroker'], 'blade.compiler' =&gt; ['Illuminate\\View\\Compilers\\BladeCompiler'], 'cache' =&gt; ['Illuminate\\Cache\\CacheManager', 'Illuminate\\Contracts\\Cache\\Factory'], 'cache.store' =&gt; ['Illuminate\\Cache\\Repository', 'Illuminate\\Contracts\\Cache\\Repository'], 'config' =&gt; ['Illuminate\\Config\\Repository', 'Illuminate\\Contracts\\Config\\Repository'], 'cookie' =&gt; ['Illuminate\\Cookie\\CookieJar', 'Illuminate\\Contracts\\Cookie\\Factory', 'Illuminate\\Contracts\\Cookie\\QueueingFactory'], 'encrypter' =&gt; ['Illuminate\\Encryption\\Encrypter', 'Illuminate\\Contracts\\Encryption\\Encrypter'], 'db' =&gt; ['Illuminate\\Database\\DatabaseManager'], 'db.connection' =&gt; ['Illuminate\\Database\\Connection', 'Illuminate\\Database\\ConnectionInterface'], 'events' =&gt; ['Illuminate\\Events\\Dispatcher', 'Illuminate\\Contracts\\Events\\Dispatcher'], 'files' =&gt; ['Illuminate\\Filesystem\\Filesystem'], 'filesystem' =&gt; ['Illuminate\\Filesystem\\FilesystemManager', 'Illuminate\\Contracts\\Filesystem\\Factory'], 'filesystem.disk' =&gt; ['Illuminate\\Contracts\\Filesystem\\Filesystem'], 'filesystem.cloud' =&gt; ['Illuminate\\Contracts\\Filesystem\\Cloud'], 'hash' =&gt; ['Illuminate\\Contracts\\Hashing\\Hasher'], 'translator' =&gt; ['Illuminate\\Translation\\Translator', 'Symfony\\Component\\Translation\\TranslatorInterface'], 'log' =&gt; ['Illuminate\\Log\\Writer', 'Illuminate\\Contracts\\Logging\\Log', 'Psr\\Log\\LoggerInterface'], 'mailer' =&gt; ['Illuminate\\Mail\\Mailer', 'Illuminate\\Contracts\\Mail\\Mailer', 'Illuminate\\Contracts\\Mail\\MailQueue'], 'auth.password' =&gt; ['Illuminate\\Auth\\Passwords\\PasswordBrokerManager', 'Illuminate\\Contracts\\Auth\\PasswordBrokerFactory'], 'auth.password.broker' =&gt; ['Illuminate\\Auth\\Passwords\\PasswordBroker', 'Illuminate\\Contracts\\Auth\\PasswordBroker'], 'queue' =&gt; ['Illuminate\\Queue\\QueueManager', 'Illuminate\\Contracts\\Queue\\Factory', 'Illuminate\\Contracts\\Queue\\Monitor'], 'queue.connection' =&gt; ['Illuminate\\Contracts\\Queue\\Queue'], 'redirect' =&gt; ['Illuminate\\Routing\\Redirector'], 'redis' =&gt; ['Illuminate\\Redis\\Database', 'Illuminate\\Contracts\\Redis\\Database'], 'request' =&gt; ['Illuminate\\Http\\Request', 'Symfony\\Component\\HttpFoundation\\Request'], 'router' =&gt; ['Illuminate\\Routing\\Router', 'Illuminate\\Contracts\\Routing\\Registrar'], 'session' =&gt; ['Illuminate\\Session\\SessionManager'], 'session.store' =&gt; ['Illuminate\\Session\\Store', 'Symfony\\Component\\HttpFoundation\\Session\\SessionInterface'], 'url' =&gt; ['Illuminate\\Routing\\UrlGenerator', 'Illuminate\\Contracts\\Routing\\UrlGenerator'], 'validator' =&gt; ['Illuminate\\Validation\\Factory', 'Illuminate\\Contracts\\Validation\\Factory'], 'view' =&gt; ['Illuminate\\View\\Factory', 'Illuminate\\Contracts\\View\\Factory'], ]; foreach ($aliases as $key =&gt; $aliases) { foreach ($aliases as $alias) { $this-&gt;alias($key, $alias); } } } 构造函数会调用registerCoreContainerAliases方法，这个方法里的aliases数组就有db，对应的类就是Illuminate\\Database\\DatabaseManager，那就也就是DB::select会调用Illuminate\\Database\\DatabaseManager::select","link":"/2016/02/01/facede/"},{"title":"Laravel路由分析","text":"在Laravel的社区找了一下，没有什么文档是分析Laravel路由的。 于是想到了一个比较投巧的方式来分析。 在routes.php加上这句 1Route::controller('finance', \"FinanceController2\"); 因为FinanceController2不存在，所以会报这个错误： 1234567891011121314151617181920212223242526272829ReflectionException in ControllerInspector.php line 35:Class App\\Http\\Controllers\\FinanceController2 does not existin ControllerInspector.php line 35at ReflectionClass-&gt;__construct('App\\Http\\Controllers\\FinanceController2') in ControllerInspector.php line 35at ControllerInspector-&gt;getRoutable('App\\Http\\Controllers\\FinanceController2', 'finance') in Router.php line 258at Router-&gt;controller('finance', 'FinanceController2') in Facade.php line 219at Facade::__callStatic('controller', array('finance', 'FinanceController2')) in routes.php line 18at Route::controller('finance', 'FinanceController2') in routes.php line 18at require('/Code/server/laravel-v5.2.0/app/Http/routes.php') in RouteServiceProvider.php line 41at RouteServiceProvider-&gt;App\\Providers{closure}(object(Router))at call_user_func(object(Closure), object(Router)) in Router.php line 379at Router-&gt;group(array('namespace' =&gt; 'App\\Http\\Controllers'), object(Closure)) in RouteServiceProvider.php line 42at RouteServiceProvider-&gt;map(object(Router))at call_user_func_array(array(object(RouteServiceProvider), 'map'), array(object(Router))) in Container.php line 507at Container-&gt;call(array(object(RouteServiceProvider), 'map')) in RouteServiceProvider.php line 72at RouteServiceProvider-&gt;loadRoutes() in RouteServiceProvider.php line 31at RouteServiceProvider-&gt;boot(object(Router)) in RouteServiceProvider.php line 29at RouteServiceProvider-&gt;boot(object(Router))at call_user_func_array(array(object(RouteServiceProvider), 'boot'), array(object(Router))) in Container.php line 507at Container-&gt;call(array(object(RouteServiceProvider), 'boot')) in Application.php line 734at Application-&gt;bootProvider(object(RouteServiceProvider)) in Application.php line 717at Application-&gt;Illuminate\\Foundation{closure}(object(RouteServiceProvider), '14')at array_walk(array(object(EventServiceProvider), object(RoutingServiceProvider), object(AuthServiceProvider), object(CookieServiceProvider), object(DatabaseServiceProvider), object(EncryptionServiceProvider), object(FilesystemServiceProvider), object(FoundationServiceProvider), object(PaginationServiceProvider), object(SessionServiceProvider), object(ViewServiceProvider), object(AppServiceProvider), object(AuthServiceProvider), object(EventServiceProvider), object(RouteServiceProvider)), object(Closure)) in Application.php line 718at Application-&gt;boot() in BootProviders.php line 17at BootProviders-&gt;bootstrap(object(Application)) in Application.php line 203at Application-&gt;bootstrapWith(array('Illuminate\\Foundation\\Bootstrap\\DetectEnvironment', 'Illuminate\\Foundation\\Bootstrap\\LoadConfiguration', 'Illuminate\\Foundation\\Bootstrap\\ConfigureLogging', 'Illuminate\\Foundation\\Bootstrap\\HandleExceptions', 'Illuminate\\Foundation\\Bootstrap\\RegisterFacades', 'Illuminate\\Foundation\\Bootstrap\\RegisterProviders', 'Illuminate\\Foundation\\Bootstrap\\BootProviders')) in Kernel.php line 232at Kernel-&gt;bootstrap() in Kernel.php line 127at Kernel-&gt;sendRequestThroughRouter(object(Request)) in Kernel.php line 99at Kernel-&gt;handle(object(Request)) in index.php line 54 从这个报错可以看出，Laravel的Route架构。 FinanceController2在Illuminate\\Routing\\Router::controller方法里先判断Router是否有设置groupStack，如果有，会把FinanceController2改成App\\Http\\Controllers\\FinanceController2，即prependGroupUses方法，然后(new ControllerInspector)-&gt;getRoutable才去查找这个类。 1234if (! empty($this-&gt;groupStack)) { $prepended = $this-&gt;prependGroupUses($controller);}$routable = (new ControllerInspector)-&gt;getRoutable($prepended, $uri); groupStack是一个数组，在App\\Providers\\RouteServiceProvider类里把这个值初始化，map方法，map方法在在父类调用。 123456789101112131415namespace App\\Providers;use Illuminate\\Routing\\Router;use Illuminate\\Foundation\\Support\\Providers\\RouteServiceProvider as ServiceProvider;class RouteServiceProvider extends ServiceProvider{ protected $namespace = 'App\\Http\\Controllers'; public function map(Router $router) { $router-&gt;group(['namespace' =&gt; $this-&gt;namespace], function ($router) { require app_path('Http/routes.php'); }); }} 而App\\Providers\\RouteServiceProvider在config/app.php里配置 这里再提下类的加载机制： 在vendor\\composer\\autoload_real.php下 12345$classMap = require __DIR__ . '/autoload_classmap.php';if ($classMap) { $loader-&gt;addClassMap($classMap);}$loader-&gt;register(true); autoload_classmap.php加载一些已经确定的类，在\\Composer\\Autoload\\ClassLoader()里的loadClass会用到。 register方法使用的是系统的spl_autoload_register方法 1spl_autoload_register(array($this, 'loadClass'), true, $prepend); 当每次加载类的时候，就会调用ClassLoader的loadClass，如果类名是classmap的名字，会加载类，类的地址在map已经知道。当查找不在classmap的时候就会进入findFileWithExtension这个方法去找 autoload_psr4.php 这个文件定义了一些替换的规则，比如App\\Http\\Controllers\\FinanceController2，在配置里是 1&apos;App\\\\&apos; =&gt; array($baseDir . &apos;/app&apos;), 那么会改成app\\Http\\Controllers\\FinanceController2, 1234567891011if (isset($this-&gt;prefixLengthsPsr4[$first])) { foreach ($this-&gt;prefixLengthsPsr4[$first] as $prefix =&gt; $length) { if (0 === strpos($class, $prefix)) { foreach ($this-&gt;prefixDirsPsr4[$prefix] as $dir) { if (file_exists($file = $dir . DIRECTORY_SEPARATOR . substr($logicalPathPsr4, $length))) { return $file; } } } } } 想要加类的目录，那么就要设置useIncludePath，可以在bootstrap/autoload.php加上 123//加载类$loader = require LARAVEL_PATH . '/vendor/autoload.php';$loader-&gt;setUseIncludePath($path);","link":"/2016/02/02/laravel-routers/"},{"title":"Laravel配置文件分析","text":"同上一篇文章一样，社区关于介绍配置文件的文章也不多，想要了解配置文件的过程，还是要靠自己手工去查找一下。 下边是自己从源码里找到的一些关键点： 配置文件 Illuminate/Foundation/Bootstrap/LoadConfiguration.php 1234567891011121314151617181920212223242526272829303132333435363738394041424344class LoadConfiguration public function bootstrap(Application $app) { if (file_exists($cached = $app-&gt;getCachedConfigPath())) { $items = require $cached; $loadedFromCache = true; } $app-&gt;instance('config', $config = new Repository($items)); if (! isset($loadedFromCache)) { $this-&gt;loadConfigurationFiles($app, $config); } $app-&gt;detectEnvironment(function () use ($config) { return $config-&gt;get('app.env', 'production'); }); date_default_timezone_set($config['app.timezone']); mb_internal_encoding('UTF-8'); } protected function loadConfigurationFiles(Application $app, RepositoryContract $repository) { foreach ($this-&gt;getConfigurationFiles($app) as $key =&gt; $path) { $repository-&gt;set($key, require $path); } } protected function getConfigurationFiles(Application $app) { $files = []; $configPath = realpath($app-&gt;configPath()); foreach (Finder::create()-&gt;files()-&gt;name('*.php')-&gt;in($configPath) as $file) { $nesting = $this-&gt;getConfigurationNesting($file, $configPath); $files[$nesting.basename($file-&gt;getRealPath(), '.php')] = $file-&gt;getRealPath(); } return $files; } 这个方法loadConfigurationFiles就是加载config下的*.php配置文件 123456789101112131415class Application { public function __construct($basePath = null) { $this-&gt;registerBaseBindings(); $this-&gt;registerBaseServiceProviders(); $this-&gt;registerCoreContainerAliases(); if ($basePath) { $this-&gt;setBasePath($basePath); } }} 这个Application在是bootstrap/app.php下加载的 123$app = new Illuminate\\Foundation\\Application( realpath(__DIR__.&apos;/../&apos;));","link":"/2016/02/03/laravel-config/"},{"title":"Mysql存储引擎","text":"Mysql是现在最流行的数据库之一，绝大多数的互联网公司都用到Mysql，占据了很大的一片市场。 MySQL是一个关系型数据库管理系统，由瑞典MySQL AB 公司开发，目前属于 Oracle 旗下产品。MySQL 是最流行的关系型数据库管理系统之一，在 WEB 应用方面，MySQL是最好的 RDBMS (Relational Database Management System，关系数据库管理系统) 应用软件之一。 MySQL是一种关系数据库管理系统，关系数据库将数据保存在不同的表中，而不是将所有数据放在一个大仓库内，这样就增加了速度并提高了灵活性。 MySQL所使用的 SQL 语言是用于访问数据库的最常用标准化语言。MySQL 软件采用了双授权政策，分为社区版和商业版，由于其体积小、速度快、总体拥有成本低，尤其是开放源码这一特点，一般中小型网站的开发都选择 MySQL作为网站数据库。 由于其社区版的性能卓越，搭配 PHP 和 Apache 可组成良好的开发环境。 MySql中有哪些存储引擎？1. MyISAM：这种引擎是mysql最早提供的。这种引擎又可以分为静态MyISAM、动态MyISAM 和压缩MyISAM三种： 静态MyISAM：如果数据表中的各数据列的长度都是预先固定好的，服务器将自动选择这种表类型。因为数据表中每一条记录所占用的空间都是一样的，所以这种表存取和更新的效率非常高。当数据受损时，恢复工作也比较容易做。 动态MyISAM：如果数据表中出现varchar、xxxtext或xxxBLOB字段时，服务器将自动选择这种表类型。相对于静态MyISAM，这种表存储空间比较小，但由于每条记录的长度不一，所以多次修改数据后，数据表中的数据就可能离散的存储在内存中，进而导致执行效率下降。同时，内存中也可能会出现很多碎片。因此，这种类型的表要经常用optimize table 命令或优化工具来进行碎片整理。 压缩MyISAM：以上说到的两种类型的表都可以用myisamchk工具压缩。这种类型的表进一步减小了占用的存储，但是这种表压缩之后不能再被修改。另外，因为是压缩数据，所以这种表在读取的时候要先时行解压缩。 但是，不管是何种MyISAM表，目前它都不支持事务，行级锁和外键约束的功能。 2. MyISAM Merge引擎：这种类型是MyISAM类型的一种变种。合并表是将几个相同的MyISAM表合并为一个虚表。常应用于日志和数据仓库。 3. InnoDB：InnoDB表类型可以看作是对MyISAM的进一步更新产品，它提供了事务、行级锁机制和外键约束的功能。 4. memory(heap)：这种类型的数据表只存在于内存中。它使用散列索引，所以数据的存取速度非常快。因为是存在于内存中，所以这种类型常应用于临时表中。 5. archive：这种类型只支持select 和 insert语句，而且不支持索引。常应用于日志记录和聚合分析方面。 适用环境：下面是常用存储引擎的适用环境： MyISAM：默认的MySQL插件式存储引擎，它是在Web、数据仓储和其他应用环境下最常使用的存储引擎之一 InnoDB：用于事务处理应用程序，具有众多特性，包括ACID事务支持。 Memory：将所有数据保存在RAM中，在需要快速查找引用和其他类似数据的环境下，可提供极快的访问。 Merge：允许MySQL DBA或开发人员将一系列等同的MyISAM表以逻辑方式组合在一起，并作为1个对象引用它们。对于诸如数据仓储等VLDB环境十分适合。 存储引擎的区别下边是存储引擎之间的区别： 特点 Myisam BDB Memory InnoDB Archive 存储限制 没有 没有 有 64TB 没有 事务安全 支持 支持 锁机制 表锁 页锁 表锁 行锁 行锁 B树索引 支持 支持 支持 支持 哈希索引 支持 支持 全文索引 支持 集群索引 支持 数据缓存 支持 支持 索引缓存 支持 支持 支持 数据可压缩 支持 支持 空间使用 低 低 N/A 高 非常低 内存使用 低 低 中等 高 低 批量插入的速度 高 高 高 低 非常高 支持外键 支持 MyISAM与InnoDB的区别MySQL默认的存储引擎是MyISAM，其他常用的就是InnoDB了，文章来自MySQL存储引擎MyISAM与InnoDB的优劣。 至于到底用哪种存储引擎比较好？这个问题是没有定论的，需要根据你的需求和环境来衡量。所以对这两种引擎的概念、原理、异同和各自的优劣点有了详细的了解之后，再根据自己的情况选择起来就容易多了。 MyISAM InnoDB 存储结构 每张表被存放在三个文件：frm-表格定义MYD(MYData)-数据文件MYI(MYIndex)-索引文件 所有的表都保存在同一个数据文件中（也可能是多个文件，或者是独立的表空间文件），InnoDB表的大小只受限于操作系统文件的大小，一般为2GB 存储空间 MyISAM可被压缩，存储空间较小 InnoDB的表需要更多的内存和存储，它会在主内存中建立其专用的缓冲池用于高速缓冲数据和索引 可移植性、备份及恢复 由于MyISAM的数据是以文件的形式存储，所以在跨平台的数据转移中会很方便。在备份和恢复时可单独针对某个表进行操作 免费的方案可以是拷贝数据文件、备份 binlog，或者用 mysqldump，在数据量达到几十G的时候就相对痛苦了 事务安全 不支持 每次查询具有原子性 支持 具有事务(commit)、回滚(rollback)和崩溃修复能力(crash recovery capabilities)的事务安全(transaction-safe (ACID compliant))型表 AUTO_INCREMENT MyISAM表可以和其他字段一起建立联合索引 InnoDB中必须包含只有该字段的索引 SELECT MyISAM更优 INSERT InnoDB更优 UPDATE InnoDB更优 DELETE InnoDB更优 它不会重新建立表，而是一行一行的删除 COUNT without WHERE MyISAM更优。因为MyISAM保存了表的具体行数 InnoDB没有保存表的具体行数，需要逐行扫描统计，就很慢了 COUNT with WHERE 一样 一样，InnoDB也会锁表 锁 只支持表锁 支持表锁、行锁 行锁大幅度提高了多用户并发操作的新能。但是InnoDB的行锁，只是在WHERE的主键是有效的，非主键的WHERE都会锁全表的 外键 不支持 支持 FULLTEXT全文索引 支持 不支持 可以通过使用Sphinx从InnoDB中获得全文索引，会慢一点 总的来说，MyISAM和InnoDB各有优劣，各有各的使用环境。 但是InnoDB的设计目标是处理大容量数据库系统，它的CPU利用率是其它基于磁盘的关系数据库引擎所不能比的。 我觉得使用InnoDB可以应对更为复杂的情况，特别是对并发的处理要比MyISAM高效。同时结合memcache也可以缓存SELECT来减少SELECT查询，从而提高整体性能。","link":"/2016/03/14/mysql-engine/"}],"tags":[{"name":"java","slug":"java","link":"/tags/java/"},{"name":"eclipse","slug":"eclipse","link":"/tags/eclipse/"},{"name":"shell","slug":"shell","link":"/tags/shell/"},{"name":"tech","slug":"tech","link":"/tags/tech/"}],"categories":[{"name":"tech","slug":"tech","link":"/categories/tech/"}]}